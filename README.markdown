# Treealoc: Субаллокатор памяти на основе B-дерева

## Описание

Проект представляет собой **субаллокатор памяти**, который использует **B-дерево** для эффективного управления выделенными и освобождёнными блоками памяти в адресном пространстве процесса. Субаллокатор инкапсулирован в динамическую библиотеку `libtreealoc.so`, которая перехватывает стандартные функции управления памятью (`malloc`, `free`, `realloc`, `calloc`) с помощью механизма `--wrap` компоновщика. Для наглядности и отладки реализована **визуализация структуры B-дерева** с использованием библиотек SDL2 и SDL2_ttf, что позволяет наблюдать за процессом выделения и освобождения памяти в реальном времени.

## Основные компоненты

-   **B-дерево (`src/b_tree.c`, `src/b_tree.h`)**:
    -   Используется как **индексная структура данных** для хранения метаданных о блоках памяти (адрес, размер, статус — занятый или свободный).
    -   Обеспечивает **логарифмическую сложность** ($O(\log N)$) для операций вставки, удаления и поиска блоков, что критически важно для производительности.
    -   Реализованы функции:
        -   `btree_insert`: Вставка информации о новом блоке в дерево.
        -   `btree_remove`: Удаление информации о блоке из дерева (с освобождением системной памяти).
        -   `btree_find_best_fit`: Поиск **наилучшего подходящего (best-fit)** свободного блока — блока, чей размер равен или минимально превосходит запрошенный.
        -   Вспомогательные функции для балансировки дерева: `split_child`, `fill_child`, `merge_nodes` и др.
-   **Субаллокатор (`src/Lib.c`, `src/Lib.h`)**:
    -   Предоставляет интерфейс, аналогичный стандартным функциям `malloc`, `free`, `realloc`, `calloc`.
    -   Функции `treealoc_malloc`, `treealoc_realloc`, `treealoc_calloc`, `treealoc_free` управляют памятью, взаимодействуя с B-деревом. При необходимости выделения новой памяти, текущая реализация запрашивает её у системного `malloc`, а затем помещает под управление B-дерева.
    -   Включает систему логирования в файл `treealoc.log`.
-   **Визуализация (`src/visual.c`, `src/visual.h`)**:
    -   Отображает текущую структуру B-дерева и состояние блоков памяти в графическом окне.
    -   Каждый узел представлен как блок с указанием размера и адреса.
    -   Визуализация использует цвета: тёмно-красный для занятых блоков, тёмно-зелёный для свободных.
    -   Позволяет отслеживать динамику выделения и освобождения памяти.
    -   Ведется логирование в `visual.log`.
-   **Тестовый модуль (`src/test.c`)**:
    -   Содержит различные тестовые сценарии для проверки функциональности аллокатора.
    -   Использует механизм **`--wrap`** GCC для перехвата стандартных вызовов `malloc`/`free` и их перенаправления на функции `treealoc_malloc`/`treealoc_free`, что позволяет тестировать ваш аллокатор, не меняя код тестовой программы.
    -   Запускает визуализатор в отдельном потоке.

## Сборка и запуск

Проект использует `Makefile` для автоматизации сборки.

### Требования

* GCC (GNU Compiler Collection)
* SDL2 Development Libraries
* SDL2_ttf Development Libraries
* `make` утилита

### Инструкции по сборке

1.  **Клонируйте репозиторий:**
    ```bash
    git clone <адрес_вашего_репозитория>
    cd <имя_папки_проекта>
    ```
2.  **Сборка проекта:**
    Выполните команду `make` в корневой директории проекта:
    ```bash
    make
    ```
    Это скомпилирует динамическую библиотеку `libtreealoc.so` (в `build/`) и тестовый исполняемый файл `test` (также в `build/`).

3.  **Установка библиотеки (опционально, но рекомендуется для других проектов):**
    Чтобы установить `libtreealoc.so` в системные пути и сделать её доступной для других программ, выполните:
    ```bash
    sudo make install
    ```
    После этого, **очень важно** обновить кеш системного компоновщика:
    ```bash
    sudo ldconfig
    ```

### Запуск тестов

1.  **Запуск тестового исполняемого файла:**
    После сборки, вы можете запустить тестовую программу:
    ```bash
    ./build/test
    ```
    Это запустит приложение с текстовым меню и отдельным окном визуализатора.

2.  **Запуск вашей программы (`app.c`):**
    Если вы используете свой `app.c` в отдельной директории (например, `test_project`), убедитесь, что `libtreealoc.so` установлена (см. `sudo make install` и `sudo ldconfig`). Затем скомпилируйте:
    ```bash
    gcc app.c -o my_app -ltreealoc
    ./my_app
    ```
    (Если `ldconfig` не помог, используйте `gcc app.c -o my_app -ltreealoc -Wl,-rpath=/usr/local/lib`)

## Использование и управление

### Тестовая программа (`./build/test`)

1.  **Меню тестов**:
    -   `1`: Простое выделение/освобождение (`malloc`/`free`).
    -   `2`: Перераспределение памяти (`realloc`).
    -   `3`: Выделение с обнулением (`calloc`).
    -   `4`: Интенсивное выделение/освобождение (50 блоков).
    -   `5`: Тест на фрагментацию памяти.
    -   `6`: Проверка граничных случаев.
    -   `7`: Запуск всех тестов.
    -   `0`: Выход.
    -   Каждый тест сопровождается логированием в консоль и обновлением визуализации.

2.  **Управление визуализацией**:
    -   Перемещение по дереву: клавиши WASD.
    -   Масштабирование: `+` (увеличение) и `-` (уменьшение).
    -   Полноэкранный режим: клавиша `F` (переключение).
    -   Закрытие окна: крестик или Ctrl+C в терминале.

### Пример вывода визуализации

* Каждый узел отображает размер блока и адрес (например, `91\n0x7cbcb0`).
* Занятые блоки — тёмно-красные, свободные — тёмно-зелёные.
* Узлы имеют белую обводку и тень для улучшенного дизайна.

## Ограничения и потенциальные улучшения (для дальнейшего развития)

-   **Текущая стратегия выделения памяти**: `treealoc_malloc` при отсутствии свободных блоков использует системный `malloc`. Для более полной реализации аллокатора, вместо этого следует запрашивать память у ОС напрямую (например, через `mmap` или `sbrk`).
-   **Отсутствие слияния свободных блоков (coalescing)**: При освобождении памяти, соседние свободные блоки не объединяются. Это может привести к внешней фрагментации. Реализация слияния позволит создавать более крупные свободные блоки.
-   **Отсутствие разделения блоков (splitting)**: Если найденный свободный блок значительно больше запрошенного, он используется целиком. Разделение блока на два (занятый и меньший свободный) улучшило бы внутреннюю фрагментацию.
-   **Потокобезопасность**: Текущая реализация не является потокобезопасной. Для использования в многопоточных приложениях необходимо добавить механизмы синхронизации (например, мьютексы) для защиты B-дерева и других общих ресурсов.
-   **Оптимизация сравнения указателей**: В `b_tree.c`, сравнение `void*` для сортировки ключей (`node->blocks[i] > ptr`) следует заменить на сравнение `uintptr_t` для обеспечения переносимости и надежности.
-   **Обработка ошибок**: Расширить проверки на `NULL` после выделения памяти.

---

## Лицензия

Проект распространяется под лицензией MIT. См. файл `LICENSE` для подробностей.